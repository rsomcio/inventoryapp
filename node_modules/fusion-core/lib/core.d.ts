import type { cleanupFn } from './types';
export declare class App {
    taskMap: Map<any, any>;
    resolved: Map<any, any>;
    count: number;
    unresolvedAsyncCount: number;
    registeredTokens: Set<any>;
    enhancerChainRoots: Map<any, any>;
    enhancerChainTails: Map<any, any>;
    enhancerTokens: Map<any, any>;
    cleanups: Array<cleanupFn>;
    wrappers: Array<any>;
    renderSetup: Array<any>;
    universalValues: Object;
    prepareBoundary: Boundary;
    pending: Set<any>;
    activeTask: any;
    constructor();
    registerPlugin(id: any, taskFn: any, param?: any): {
        alias: (from: any, to: any) => void;
    };
    enhance(id: any, enhancer: any): void;
    init(): Promise<unknown>;
    _setRef(): void;
    _clearRef(): void;
}
export declare function withDeps(deps: any): Deps;
declare class Deps {
    deps: any;
    constructor(deps: any);
    /**
     * If deps are yielded, we handle the following scenarios:
     * A) If every token has already been resolved, simply resume generator
     * execution with the resolved values by invoking `gen.next(values)`.
     * B) There are unresolved tokens, move this task to the end and continue
     */
    advance(app: any, task: any): 0 | 1;
}
export declare function withStartup(fn: any): Startup;
declare class Startup {
    startup: any;
    constructor(startup: any);
    /**
     * If startup function is yielded, we invoke the function and temporarily remove
     * the generator from the pending list.
     * When the startup function resolves, we resume its execution with the resolved
     * value and add the generator back to the pending list.
     * Note that we need to keep track of how many ongoing async functions there are
     * so we don't prematurely resolve the init function (i.e. there's no pending
     * tasks, just an async function).
     */
    advance(app: any, task: any, resolve: any): number;
}
declare class Child {
    plugin: any;
    param: any;
    deps: any;
    ref: any;
    injected: any;
    constructor({ plugin, param, deps, ref }: {
        plugin: any;
        param: any;
        deps: any;
        ref: any;
    });
    /**
     If a child plugin is yielded, we register the child under a hidden token.
     Then we consider the parent to dependend on the child via this hidden token.
  
     So effectively, the following:
  
     - TokenA: ParentPlugin
       - child = withPlugin(ChildPlugin)
  
     becomes:
  
     - HiddenTokenB: ChildPlugin
     - TokenA: ParentPlugin
       - child = withDep(HiddenTokenB)
  
     In the future, it may make sense to just yield the child generator function,
     which would result in a more straightforward linear execution (with less jumping around).
     However, dealing with private/encapsulated deps is possibly a bit more tricky.
     */
    advance(app: any, task: any): number;
}
export declare const withPlugin: {
    (plugin: any, param?: any): Child;
    using(token: any, val: any): any;
};
export declare function withMiddleware(middleware: any): void;
export declare function withUniversalMiddleware(middleware: any): void;
export declare function withCleanup(cleanup: any): void;
export declare function withUniversalValue(id: any): ((val: any) => void)[];
export declare function withEndpoint(endpointPath: any, fn: any): void;
export declare function withRenderSetup(fn: any): void;
export declare function unstable_withPrepareEffect(effectFn: any): void;
export declare function getResolvedDep(app: any, id: any): {
    resolved: boolean;
    value: any;
    eventual: any;
} | {
    resolved: boolean;
    eventual: any;
    value?: undefined;
};
declare class Boundary {
    private effects;
    private id;
    private resolved;
    constructor(id: string);
    addEffect(effect: any): void;
    reset(): void;
    done(): void;
}
export {};
//# sourceMappingURL=core.d.ts.map