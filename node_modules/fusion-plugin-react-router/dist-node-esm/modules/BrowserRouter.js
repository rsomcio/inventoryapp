function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
import * as React from 'react';
import PropTypes from 'prop-types';
import { Router as BaseRouter } from 'react-router-dom';
import compare from 'just-compare';
import { jsx as _jsx } from "react/jsx-runtime";
export { Status, NotFound } from './Status.js';
export { Redirect } from './Redirect.js';

class BrowserRouter extends React.Component {
  constructor(props, context) {
    super(props, context);
    this.lastTitle = null;
  }

  getChildContext() {
    const {
      __IS_PREPARE__
    } = this.context;
    return {
      onRoute: routeData => {
        if (!__IS_PREPARE__ && (routeData.title !== this.lastTitle || !compare(routeData.params, this.lastParams))) {
          this.lastTitle = routeData.title;
          this.lastParams = routeData.params;
          this.props.onRoute && this.props.onRoute(routeData);
        }
      }
    };
  }

  render() {
    const {
      Provider,
      history,
      basename
    } = this.props;
    if (!Provider) throw new Error('Missing Provider for Browser Router');
    return (
      /*#__PURE__*/
      // $FlowFixMe
      _jsx(Provider, {
        basename: basename,
        history: history,
        children: this.props.children
      })
    );
  }

}

_defineProperty(BrowserRouter, "defaultProps", {
  onRoute: () => {},
  Provider: BaseRouter
});

BrowserRouter.propTypes = {
  children: PropTypes.node,
  onRoute: PropTypes.func,
  history: PropTypes.object,
  Provider: PropTypes.any,
  basename: PropTypes.string
};
BrowserRouter.contextTypes = {
  __IS_PREPARE__: PropTypes.bool
};
BrowserRouter.childContextTypes = {
  onRoute: PropTypes.func.isRequired
};
const BrowserRouterTyped = BrowserRouter;
export { BrowserRouterTyped as Router };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9tb2R1bGVzL0Jyb3dzZXJSb3V0ZXIuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJSb3V0ZXIiLCJCYXNlUm91dGVyIiwiY29tcGFyZSIsIlN0YXR1cyIsIk5vdEZvdW5kIiwiUmVkaXJlY3QiLCJCcm93c2VyUm91dGVyIiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImNvbnRleHQiLCJsYXN0VGl0bGUiLCJnZXRDaGlsZENvbnRleHQiLCJfX0lTX1BSRVBBUkVfXyIsIm9uUm91dGUiLCJyb3V0ZURhdGEiLCJ0aXRsZSIsInBhcmFtcyIsImxhc3RQYXJhbXMiLCJyZW5kZXIiLCJQcm92aWRlciIsImhpc3RvcnkiLCJiYXNlbmFtZSIsIkVycm9yIiwiY2hpbGRyZW4iLCJwcm9wVHlwZXMiLCJub2RlIiwiZnVuYyIsIm9iamVjdCIsImFueSIsInN0cmluZyIsImNvbnRleHRUeXBlcyIsImJvb2wiLCJjaGlsZENvbnRleHRUeXBlcyIsImlzUmVxdWlyZWQiLCJCcm93c2VyUm91dGVyVHlwZWQiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxPQUFPLEtBQUtBLEtBQVosTUFBdUIsT0FBdkI7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsU0FBUUMsTUFBTSxJQUFJQyxVQUFsQixRQUFtQyxrQkFBbkM7QUFDQSxPQUFPQyxPQUFQLE1BQW9CLGNBQXBCOztBQUlBLFNBQVFDLE1BQVIsRUFBZ0JDLFFBQWhCLFFBQStCLGFBQS9CO0FBQ0EsU0FBUUMsUUFBUixRQUF1QixlQUF2Qjs7QUFLQSxNQUFNQyxhQUFOLFNBQTRCUixLQUFLLENBQUNTLFNBQWxDLENBQXVEO0FBVXJEQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBbUJDLE9BQW5CLEVBQXlDO0FBQ2xELFVBQU1ELEtBQU4sRUFBYUMsT0FBYjtBQUNBLFNBQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDRDs7QUFFREMsRUFBQUEsZUFBZSxHQUFHO0FBQ2hCLFVBQU07QUFBQ0MsTUFBQUE7QUFBRCxRQUFtQixLQUFLSCxPQUE5QjtBQUNBLFdBQU87QUFDTEksTUFBQUEsT0FBTyxFQUFHQyxTQUFELElBQW9CO0FBQzNCLFlBQ0UsQ0FBQ0YsY0FBRCxLQUNDRSxTQUFTLENBQUNDLEtBQVYsS0FBb0IsS0FBS0wsU0FBekIsSUFDQyxDQUFDVCxPQUFPLENBQUNhLFNBQVMsQ0FBQ0UsTUFBWCxFQUFtQixLQUFLQyxVQUF4QixDQUZWLENBREYsRUFJRTtBQUNBLGVBQUtQLFNBQUwsR0FBaUJJLFNBQVMsQ0FBQ0MsS0FBM0I7QUFDQSxlQUFLRSxVQUFMLEdBQWtCSCxTQUFTLENBQUNFLE1BQTVCO0FBQ0EsZUFBS1IsS0FBTCxDQUFXSyxPQUFYLElBQXNCLEtBQUtMLEtBQUwsQ0FBV0ssT0FBWCxDQUFtQkMsU0FBbkIsQ0FBdEI7QUFDRDtBQUNGO0FBWEksS0FBUDtBQWFEOztBQUVESSxFQUFBQSxNQUFNLEdBQUc7QUFDUCxVQUFNO0FBQUNDLE1BQUFBLFFBQUQ7QUFBV0MsTUFBQUEsT0FBWDtBQUFvQkMsTUFBQUE7QUFBcEIsUUFBZ0MsS0FBS2IsS0FBM0M7QUFDQSxRQUFJLENBQUNXLFFBQUwsRUFBZSxNQUFNLElBQUlHLEtBQUosQ0FBVSxxQ0FBVixDQUFOO0FBQ2Y7QUFBQTtBQUNFO0FBQ0EsV0FBQyxRQUFEO0FBQVUsUUFBQSxRQUFRLEVBQUVELFFBQXBCO0FBQThCLFFBQUEsT0FBTyxFQUFFRCxPQUF2QztBQUFBLGtCQUNHLEtBQUtaLEtBQUwsQ0FBV2U7QUFEZDtBQUZGO0FBTUQ7O0FBekNvRDs7Z0JBQWpEbEIsYSxrQkFLa0I7QUFDcEJRLEVBQUFBLE9BQU8sRUFBRSxNQUFNLENBQUUsQ0FERztBQUVwQk0sRUFBQUEsUUFBUSxFQUFFbkI7QUFGVSxDOztBQXVDeEJLLGFBQWEsQ0FBQ21CLFNBQWQsR0FBMEI7QUFDeEJELEVBQUFBLFFBQVEsRUFBRXpCLFNBQVMsQ0FBQzJCLElBREk7QUFFeEJaLEVBQUFBLE9BQU8sRUFBRWYsU0FBUyxDQUFDNEIsSUFGSztBQUd4Qk4sRUFBQUEsT0FBTyxFQUFFdEIsU0FBUyxDQUFDNkIsTUFISztBQUl4QlIsRUFBQUEsUUFBUSxFQUFFckIsU0FBUyxDQUFDOEIsR0FKSTtBQUt4QlAsRUFBQUEsUUFBUSxFQUFFdkIsU0FBUyxDQUFDK0I7QUFMSSxDQUExQjtBQVFBeEIsYUFBYSxDQUFDeUIsWUFBZCxHQUE2QjtBQUMzQmxCLEVBQUFBLGNBQWMsRUFBRWQsU0FBUyxDQUFDaUM7QUFEQyxDQUE3QjtBQUlBMUIsYUFBYSxDQUFDMkIsaUJBQWQsR0FBa0M7QUFDaENuQixFQUFBQSxPQUFPLEVBQUVmLFNBQVMsQ0FBQzRCLElBQVYsQ0FBZU87QUFEUSxDQUFsQztBQUlBLE1BQU1DLGtCQUE4QixHQUFHN0IsYUFBdkM7QUFDQSxTQUFRNkIsa0JBQWtCLElBQUluQyxNQUE5QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQge1JvdXRlciBhcyBCYXNlUm91dGVyfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCBjb21wYXJlIGZyb20gJ2p1c3QtY29tcGFyZSc7XG5cbmltcG9ydCB0eXBlIHtSb3V0ZXJQcm9wc1R5cGUgYXMgUHJvcHNUeXBlLCBSb3V0ZXJUeXBlfSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCB7U3RhdHVzLCBOb3RGb3VuZH0gZnJvbSAnLi9TdGF0dXMuanMnO1xuZXhwb3J0IHtSZWRpcmVjdH0gZnJvbSAnLi9SZWRpcmVjdC5qcyc7XG5cbnR5cGUgQ29udGV4dFR5cGUgPSB7XG4gIF9fSVNfUFJFUEFSRV9fOiBib29sZWFuLFxufTtcbmNsYXNzIEJyb3dzZXJSb3V0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHNUeXBlPiB7XG4gIGxhc3RUaXRsZTogP3N0cmluZztcbiAgbGFzdFBhcmFtczoge307XG4gIGNvbnRleHQ6IENvbnRleHRUeXBlO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgb25Sb3V0ZTogKCkgPT4ge30sXG4gICAgUHJvdmlkZXI6IEJhc2VSb3V0ZXIsXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzVHlwZSwgY29udGV4dDogQ29udGV4dFR5cGUpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgdGhpcy5sYXN0VGl0bGUgPSBudWxsO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIGNvbnN0IHtfX0lTX1BSRVBBUkVfX30gPSB0aGlzLmNvbnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm91dGU6IChyb3V0ZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIV9fSVNfUFJFUEFSRV9fICYmXG4gICAgICAgICAgKHJvdXRlRGF0YS50aXRsZSAhPT0gdGhpcy5sYXN0VGl0bGUgfHxcbiAgICAgICAgICAgICFjb21wYXJlKHJvdXRlRGF0YS5wYXJhbXMsIHRoaXMubGFzdFBhcmFtcykpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubGFzdFRpdGxlID0gcm91dGVEYXRhLnRpdGxlO1xuICAgICAgICAgIHRoaXMubGFzdFBhcmFtcyA9IHJvdXRlRGF0YS5wYXJhbXM7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vblJvdXRlICYmIHRoaXMucHJvcHMub25Sb3V0ZShyb3V0ZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1Byb3ZpZGVyLCBoaXN0b3J5LCBiYXNlbmFtZX0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghUHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBQcm92aWRlciBmb3IgQnJvd3NlciBSb3V0ZXInKTtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgPFByb3ZpZGVyIGJhc2VuYW1lPXtiYXNlbmFtZX0gaGlzdG9yeT17aGlzdG9yeX0+XG4gICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgPC9Qcm92aWRlcj5cbiAgICApO1xuICB9XG59XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIG9uUm91dGU6IFByb3BUeXBlcy5mdW5jLFxuICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LFxuICBQcm92aWRlcjogUHJvcFR5cGVzLmFueSxcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG59O1xuXG5Ccm93c2VyUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgX19JU19QUkVQQVJFX186IFByb3BUeXBlcy5ib29sLFxufTtcblxuQnJvd3NlclJvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgb25Sb3V0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IEJyb3dzZXJSb3V0ZXJUeXBlZDogUm91dGVyVHlwZSA9IEJyb3dzZXJSb3V0ZXI7XG5leHBvcnQge0Jyb3dzZXJSb3V0ZXJUeXBlZCBhcyBSb3V0ZXJ9O1xuIl19