"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Status", {
  enumerable: true,
  get: function () {
    return _Status.Status;
  }
});
Object.defineProperty(exports, "NotFound", {
  enumerable: true,
  get: function () {
    return _Status.NotFound;
  }
});
Object.defineProperty(exports, "Redirect", {
  enumerable: true,
  get: function () {
    return _Redirect.Redirect;
  }
});
exports.Router = void 0;

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactRouterDom = require("react-router-dom");

var _justCompare = _interopRequireDefault(require("just-compare"));

var _jsxRuntime = require("react/jsx-runtime");

var _Status = require("./Status.js");

var _Redirect = require("./Redirect.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BrowserRouter extends React.Component {
  constructor(props, context) {
    super(props, context);
    this.lastTitle = null;
  }

  getChildContext() {
    const {
      __IS_PREPARE__
    } = this.context;
    return {
      onRoute: routeData => {
        if (!__IS_PREPARE__ && (routeData.title !== this.lastTitle || !(0, _justCompare.default)(routeData.params, this.lastParams))) {
          this.lastTitle = routeData.title;
          this.lastParams = routeData.params;
          this.props.onRoute && this.props.onRoute(routeData);
        }
      }
    };
  }

  render() {
    const {
      Provider,
      history,
      basename
    } = this.props;
    if (!Provider) throw new Error('Missing Provider for Browser Router');
    return (
      /*#__PURE__*/
      // $FlowFixMe
      (0, _jsxRuntime.jsx)(Provider, {
        basename: basename,
        history: history,
        children: this.props.children
      })
    );
  }

}

_defineProperty(BrowserRouter, "defaultProps", {
  onRoute: () => {},
  Provider: _reactRouterDom.Router
});

BrowserRouter.propTypes = {
  children: _propTypes.default.node,
  onRoute: _propTypes.default.func,
  history: _propTypes.default.object,
  Provider: _propTypes.default.any,
  basename: _propTypes.default.string
};
BrowserRouter.contextTypes = {
  __IS_PREPARE__: _propTypes.default.bool
};
BrowserRouter.childContextTypes = {
  onRoute: _propTypes.default.func.isRequired
};
const BrowserRouterTyped = BrowserRouter;
exports.Router = BrowserRouterTyped;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9tb2R1bGVzL0Jyb3dzZXJSb3V0ZXIuanMiXSwibmFtZXMiOlsiQnJvd3NlclJvdXRlciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImNvbnRleHQiLCJsYXN0VGl0bGUiLCJnZXRDaGlsZENvbnRleHQiLCJfX0lTX1BSRVBBUkVfXyIsIm9uUm91dGUiLCJyb3V0ZURhdGEiLCJ0aXRsZSIsInBhcmFtcyIsImxhc3RQYXJhbXMiLCJyZW5kZXIiLCJQcm92aWRlciIsImhpc3RvcnkiLCJiYXNlbmFtZSIsIkVycm9yIiwiY2hpbGRyZW4iLCJCYXNlUm91dGVyIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwibm9kZSIsImZ1bmMiLCJvYmplY3QiLCJhbnkiLCJzdHJpbmciLCJjb250ZXh0VHlwZXMiLCJib29sIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJpc1JlcXVpcmVkIiwiQnJvd3NlclJvdXRlclR5cGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFJQTs7QUFDQTs7Ozs7Ozs7OztBQUtBLE1BQU1BLGFBQU4sU0FBNEJDLEtBQUssQ0FBQ0MsU0FBbEMsQ0FBdUQ7QUFVckRDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFtQkMsT0FBbkIsRUFBeUM7QUFDbEQsVUFBTUQsS0FBTixFQUFhQyxPQUFiO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQixJQUFqQjtBQUNEOztBQUVEQyxFQUFBQSxlQUFlLEdBQUc7QUFDaEIsVUFBTTtBQUFDQyxNQUFBQTtBQUFELFFBQW1CLEtBQUtILE9BQTlCO0FBQ0EsV0FBTztBQUNMSSxNQUFBQSxPQUFPLEVBQUdDLFNBQUQsSUFBb0I7QUFDM0IsWUFDRSxDQUFDRixjQUFELEtBQ0NFLFNBQVMsQ0FBQ0MsS0FBVixLQUFvQixLQUFLTCxTQUF6QixJQUNDLENBQUMsMEJBQVFJLFNBQVMsQ0FBQ0UsTUFBbEIsRUFBMEIsS0FBS0MsVUFBL0IsQ0FGSCxDQURGLEVBSUU7QUFDQSxlQUFLUCxTQUFMLEdBQWlCSSxTQUFTLENBQUNDLEtBQTNCO0FBQ0EsZUFBS0UsVUFBTCxHQUFrQkgsU0FBUyxDQUFDRSxNQUE1QjtBQUNBLGVBQUtSLEtBQUwsQ0FBV0ssT0FBWCxJQUFzQixLQUFLTCxLQUFMLENBQVdLLE9BQVgsQ0FBbUJDLFNBQW5CLENBQXRCO0FBQ0Q7QUFDRjtBQVhJLEtBQVA7QUFhRDs7QUFFREksRUFBQUEsTUFBTSxHQUFHO0FBQ1AsVUFBTTtBQUFDQyxNQUFBQSxRQUFEO0FBQVdDLE1BQUFBLE9BQVg7QUFBb0JDLE1BQUFBO0FBQXBCLFFBQWdDLEtBQUtiLEtBQTNDO0FBQ0EsUUFBSSxDQUFDVyxRQUFMLEVBQWUsTUFBTSxJQUFJRyxLQUFKLENBQVUscUNBQVYsQ0FBTjtBQUNmO0FBQUE7QUFDRTtBQUNBLDJCQUFDLFFBQUQ7QUFBVSxRQUFBLFFBQVEsRUFBRUQsUUFBcEI7QUFBOEIsUUFBQSxPQUFPLEVBQUVELE9BQXZDO0FBQUEsa0JBQ0csS0FBS1osS0FBTCxDQUFXZTtBQURkO0FBRkY7QUFNRDs7QUF6Q29EOztnQkFBakRuQixhLGtCQUtrQjtBQUNwQlMsRUFBQUEsT0FBTyxFQUFFLE1BQU0sQ0FBRSxDQURHO0FBRXBCTSxFQUFBQSxRQUFRLEVBQUVLO0FBRlUsQzs7QUF1Q3hCcEIsYUFBYSxDQUFDcUIsU0FBZCxHQUEwQjtBQUN4QkYsRUFBQUEsUUFBUSxFQUFFRyxtQkFBVUMsSUFESTtBQUV4QmQsRUFBQUEsT0FBTyxFQUFFYSxtQkFBVUUsSUFGSztBQUd4QlIsRUFBQUEsT0FBTyxFQUFFTSxtQkFBVUcsTUFISztBQUl4QlYsRUFBQUEsUUFBUSxFQUFFTyxtQkFBVUksR0FKSTtBQUt4QlQsRUFBQUEsUUFBUSxFQUFFSyxtQkFBVUs7QUFMSSxDQUExQjtBQVFBM0IsYUFBYSxDQUFDNEIsWUFBZCxHQUE2QjtBQUMzQnBCLEVBQUFBLGNBQWMsRUFBRWMsbUJBQVVPO0FBREMsQ0FBN0I7QUFJQTdCLGFBQWEsQ0FBQzhCLGlCQUFkLEdBQWtDO0FBQ2hDckIsRUFBQUEsT0FBTyxFQUFFYSxtQkFBVUUsSUFBVixDQUFlTztBQURRLENBQWxDO0FBSUEsTUFBTUMsa0JBQThCLEdBQUdoQyxhQUF2QyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBDb3B5cmlnaHQgKGMpIDIwMTggVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQge1JvdXRlciBhcyBCYXNlUm91dGVyfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcbmltcG9ydCBjb21wYXJlIGZyb20gJ2p1c3QtY29tcGFyZSc7XG5cbmltcG9ydCB0eXBlIHtSb3V0ZXJQcm9wc1R5cGUgYXMgUHJvcHNUeXBlLCBSb3V0ZXJUeXBlfSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCB7U3RhdHVzLCBOb3RGb3VuZH0gZnJvbSAnLi9TdGF0dXMuanMnO1xuZXhwb3J0IHtSZWRpcmVjdH0gZnJvbSAnLi9SZWRpcmVjdC5qcyc7XG5cbnR5cGUgQ29udGV4dFR5cGUgPSB7XG4gIF9fSVNfUFJFUEFSRV9fOiBib29sZWFuLFxufTtcbmNsYXNzIEJyb3dzZXJSb3V0ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHNUeXBlPiB7XG4gIGxhc3RUaXRsZTogP3N0cmluZztcbiAgbGFzdFBhcmFtczoge307XG4gIGNvbnRleHQ6IENvbnRleHRUeXBlO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgb25Sb3V0ZTogKCkgPT4ge30sXG4gICAgUHJvdmlkZXI6IEJhc2VSb3V0ZXIsXG4gIH07XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzVHlwZSwgY29udGV4dDogQ29udGV4dFR5cGUpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgdGhpcy5sYXN0VGl0bGUgPSBudWxsO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIGNvbnN0IHtfX0lTX1BSRVBBUkVfX30gPSB0aGlzLmNvbnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm91dGU6IChyb3V0ZURhdGE6IGFueSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIV9fSVNfUFJFUEFSRV9fICYmXG4gICAgICAgICAgKHJvdXRlRGF0YS50aXRsZSAhPT0gdGhpcy5sYXN0VGl0bGUgfHxcbiAgICAgICAgICAgICFjb21wYXJlKHJvdXRlRGF0YS5wYXJhbXMsIHRoaXMubGFzdFBhcmFtcykpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubGFzdFRpdGxlID0gcm91dGVEYXRhLnRpdGxlO1xuICAgICAgICAgIHRoaXMubGFzdFBhcmFtcyA9IHJvdXRlRGF0YS5wYXJhbXM7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vblJvdXRlICYmIHRoaXMucHJvcHMub25Sb3V0ZShyb3V0ZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1Byb3ZpZGVyLCBoaXN0b3J5LCBiYXNlbmFtZX0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghUHJvdmlkZXIpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBQcm92aWRlciBmb3IgQnJvd3NlciBSb3V0ZXInKTtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgPFByb3ZpZGVyIGJhc2VuYW1lPXtiYXNlbmFtZX0gaGlzdG9yeT17aGlzdG9yeX0+XG4gICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgPC9Qcm92aWRlcj5cbiAgICApO1xuICB9XG59XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIG9uUm91dGU6IFByb3BUeXBlcy5mdW5jLFxuICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LFxuICBQcm92aWRlcjogUHJvcFR5cGVzLmFueSxcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG59O1xuXG5Ccm93c2VyUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgX19JU19QUkVQQVJFX186IFByb3BUeXBlcy5ib29sLFxufTtcblxuQnJvd3NlclJvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgb25Sb3V0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbn07XG5cbmNvbnN0IEJyb3dzZXJSb3V0ZXJUeXBlZDogUm91dGVyVHlwZSA9IEJyb3dzZXJSb3V0ZXI7XG5leHBvcnQge0Jyb3dzZXJSb3V0ZXJUeXBlZCBhcyBSb3V0ZXJ9O1xuIl19